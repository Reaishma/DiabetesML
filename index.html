<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü©∫ Diabetes Prediction ML Model</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Streamlit-inspired styling */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Source Sans Pro', sans-serif;
            background-color: #FFFFFF;
            color: #262730;
            line-height: 1.6;
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        /* Header - Streamlit style */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #FFFFFF;
            border-bottom: 1px solid #E6E9F0;
            z-index: 1000;
            padding: 1rem 2rem;
        }

        .header-content h1 {
            font-size: 2.5rem;
            font-weight: 600;
            color: #262730;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 1.1rem;
            color: #6C757D;
            font-weight: 400;
        }

        /* Sidebar - Streamlit style */
        .sidebar {
            position: fixed;
            left: 0;
            top: 140px;
            width: 280px;
            height: calc(100vh - 140px);
            background-color: #F0F2F6;
            padding: 2rem 1rem;
            border-right: 1px solid #E6E9F0;
            overflow-y: auto;
        }

        .sidebar h3 {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #262730;
        }

        .nav-menu {
            list-style: none;
        }

        .nav-menu li {
            margin-bottom: 0.5rem;
        }

        .nav-link {
            display: block;
            padding: 0.75rem 1rem;
            text-decoration: none;
            color: #262730;
            border-radius: 0.5rem;
            transition: all 0.2s ease;
            font-size: 1rem;
            cursor: pointer;
        }

        .nav-link:hover {
            background-color: #E6E9F0;
            color: #FF6B6B;
        }

        .nav-link.active {
            background-color: #FF6B6B;
            color: #FFFFFF;
        }

        /* Main content - Streamlit style */
        .main-content {
            margin-left: 280px;
            margin-top: 140px;
            padding: 2rem;
            flex: 1;
            max-width: calc(100vw - 280px);
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        .page h2 {
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #262730;
        }

        /* Metrics grid - Streamlit metric style */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .metric-card {
            background: #FFFFFF;
            border: 1px solid #E6E9F0;
            border-radius: 0.5rem;
            padding: 1.5rem;
            text-align: center;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: #262730;
            margin-bottom: 0.5rem;
        }

        .metric-label {
            font-size: 0.9rem;
            color: #6C757D;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Content sections */
        .content-section {
            background: #FFFFFF;
            border: 1px solid #E6E9F0;
            border-radius: 0.5rem;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .content-section h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #262730;
        }

        /* Tables - Streamlit dataframe style */
        .table-container {
            overflow-x: auto;
            margin: 1rem 0;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .data-table th {
            background-color: #F0F2F6;
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            border-bottom: 1px solid #E6E9F0;
            position: sticky;
            top: 0;
        }

        .data-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #F0F2F6;
        }

        .data-table tbody tr:hover {
            background-color: #F8F9FA;
        }

        /* Feature descriptions */
        .feature-descriptions {
            display: grid;
            gap: 1rem;
        }

        .feature-item {
            padding: 1rem;
            background-color: #F8F9FA;
            border-radius: 0.25rem;
            border-left: 4px solid #FF6B6B;
        }

        /* Charts */
        .chart-container {
            width: 100%;
            height: 400px;
            margin: 1rem 0;
            border: 1px solid #E6E9F0;
            border-radius: 0.5rem;
            padding: 1rem;
        }

        /* Buttons - Streamlit style */
        .btn {
            padding: 0.75rem 2rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background-color: #FF6B6B;
            color: #FFFFFF;
        }

        .btn-primary:hover {
            background-color: #FF5252;
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Training controls */
        .training-controls {
            margin-bottom: 2rem;
            text-align: center;
        }

        .training-status {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 0.5rem;
        }

        .training-status.loading {
            background-color: #FFF3CD;
            border: 1px solid #FFE69C;
            color: #856404;
        }

        .training-status.success {
            background-color: #D1E7DD;
            border: 1px solid #BADBCC;
            color: #0F5132;
        }

        /* Warning message */
        .warning-message {
            background-color: #FFF3CD;
            border: 1px solid #FFE69C;
            color: #856404;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 2rem;
        }

        /* Prediction form */
        .prediction-form {
            background: #FFFFFF;
            border: 1px solid #E6E9F0;
            border-radius: 0.5rem;
            padding: 2rem;
        }

        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .input-group label {
            font-weight: 600;
            color: #262730;
        }

        .input-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #E6E9F0;
            outline: none;
            -webkit-appearance: none;
        }

        .input-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #FF6B6B;
            cursor: pointer;
        }

        .input-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #FF6B6B;
            cursor: pointer;
            border: none;
        }

        .input-group select {
            padding: 0.5rem;
            border: 1px solid #E6E9F0;
            border-radius: 0.25rem;
            font-size: 1rem;
        }

        .input-group span {
            font-weight: 600;
            color: #FF6B6B;
        }

        /* Feature selector */
        .feature-selector {
            margin-bottom: 1rem;
        }

        .feature-selector label {
            font-weight: 600;
            margin-right: 1rem;
        }

        .feature-selector select {
            padding: 0.5rem;
            border: 1px solid #E6E9F0;
            border-radius: 0.25rem;
            font-size: 1rem;
        }

        /* Results grid */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .result-card {
            padding: 1.5rem;
            border-radius: 0.5rem;
            text-align: center;
            border: 2px solid;
        }

        .result-card.high-risk {
            background-color: #F8D7DA;
            border-color: #F5C6CB;
            color: #721C24;
        }

        .result-card.low-risk {
            background-color: #D1E7DD;
            border-color: #BADBCC;
            color: #0F5132;
        }

        .result-card h4 {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .result-card .confidence {
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        /* Confusion matrices */
        .confusion-matrices {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
        }

        .confusion-matrix {
            border: 1px solid #E6E9F0;
            border-radius: 0.5rem;
            padding: 1rem;
        }

        /* Loading spinner */
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #FF6B6B;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 0.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Mobile menu button */
        .mobile-menu-btn {
            display: none;
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 1001;
            background: #FF6B6B;
            color: white;
            border: none;
            border-radius: 0.5rem;
            padding: 0.5rem;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .mobile-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .mobile-menu-btn {
                display: block;
            }
            
            .header {
                padding: 1rem;
                padding-left: 4rem;
            }
            
            .header-content h1 {
                font-size: 1.5rem;
                margin-bottom: 0.25rem;
            }
            
            .subtitle {
                font-size: 0.9rem;
            }
            
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                width: 280px;
                height: 100vh;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 1000;
                padding-top: 1rem;
            }
            
            .sidebar.open {
                transform: translateX(0);
            }
            
            .main-content {
                margin-left: 0;
                margin-top: 120px;
                max-width: 100vw;
                padding: 1rem;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.75rem;
            }
            
            .metric-card {
                padding: 1rem;
            }
            
            .metric-value {
                font-size: 1.5rem;
            }
            
            .input-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .content-section {
                padding: 1rem;
                margin-bottom: 1rem;
            }
            
            .chart-container {
                height: 300px;
                padding: 0.5rem;
            }
            
            .data-table {
                font-size: 0.8rem;
            }
            
            .data-table th,
            .data-table td {
                padding: 0.5rem;
            }
            
            .confusion-matrices {
                grid-template-columns: 1fr;
            }
            
            .results-grid {
                grid-template-columns: 1fr;
            }
            
            .btn {
                padding: 0.75rem 1.5rem;
                font-size: 0.9rem;
            }
            
            .feature-descriptions {
                gap: 0.75rem;
            }
            
            .feature-item {
                padding: 0.75rem;
            }
        }

        @media (max-width: 480px) {
            .header-content h1 {
                font-size: 1.2rem;
            }
            
            .subtitle {
                font-size: 0.8rem;
            }
            
            .main-content {
                padding: 0.75rem;
                margin-top: 100px;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
            
            .metric-card {
                padding: 0.75rem;
            }
            
            .metric-value {
                font-size: 1.2rem;
            }
            
            .metric-label {
                font-size: 0.8rem;
            }
            
            .content-section {
                padding: 0.75rem;
            }
            
            .chart-container {
                height: 250px;
                padding: 0.25rem;
            }
            
            .page h2 {
                font-size: 1.5rem;
                margin-bottom: 1rem;
            }
            
            .content-section h3 {
                font-size: 1.2rem;
            }
            
            .sidebar {
                width: 250px;
            }
            
            .input-group label {
                font-size: 0.9rem;
            }
            
            .input-group small {
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Mobile Menu Button -->
        <button class="mobile-menu-btn" id="mobile-menu-btn">‚ò∞</button>
        
        <!-- Mobile Overlay -->
        <div class="mobile-overlay" id="mobile-overlay"></div>
        
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <h1>ü©∫ Diabetes Prediction ML Model</h1>
                <p class="subtitle">An interactive machine learning application for diabetes prediction with comprehensive data analysis</p>
            </div>
        </header>

        <!-- Navigation -->
        <nav class="sidebar">
            <h3>üìä Navigation</h3>
            <ul class="nav-menu">
                <li><a class="nav-link active" data-page="overview">
                    üìà Data Overview
                </a></li>
                <li><a class="nav-link" data-page="eda">
                    üîç Exploratory Data Analysis
                </a></li>
                <li><a class="nav-link" data-page="training">
                    ü§ñ Model Training & Evaluation
                </a></li>
                <li><a class="nav-link" data-page="prediction">
                    üîÆ Prediction Interface
                </a></li>
            </ul>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Data Overview Page -->
            <div id="overview-page" class="page active">
                <h2>üìä Dataset Overview</h2>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="total-samples">442</div>
                        <div class="metric-label">Total Samples</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="features-count">10</div>
                        <div class="metric-label">Features</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="diabetes-cases">221</div>
                        <div class="metric-label">Diabetes Cases</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="no-diabetes-cases">221</div>
                        <div class="metric-label">No Diabetes Cases</div>
                    </div>
                </div>

                <div class="content-section">
                    <h3>Dataset Sample</h3>
                    <div class="table-container">
                        <table id="dataset-table" class="data-table">
                            <thead>
                                <tr>
                                    <th>Age</th>
                                    <th>Sex</th>
                                    <th>BMI</th>
                                    <th>BP</th>
                                    <th>S1</th>
                                    <th>S2</th>
                                    <th>S3</th>
                                    <th>S4</th>
                                    <th>S5</th>
                                    <th>S6</th>
                                    <th>Diabetes</th>
                                </tr>
                            </thead>
                            <tbody id="dataset-tbody">
                                <!-- Data will be populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="content-section">
                    <h3>Feature Descriptions</h3>
                    <div class="feature-descriptions">
                        <div class="feature-item">
                            <strong>Age:</strong> Age of the patient
                        </div>
                        <div class="feature-item">
                            <strong>Sex:</strong> Sex of the patient (1 = male, -1 = female)
                        </div>
                        <div class="feature-item">
                            <strong>BMI:</strong> Body Mass Index
                        </div>
                        <div class="feature-item">
                            <strong>BP:</strong> Average Blood Pressure
                        </div>
                        <div class="feature-item">
                            <strong>S1:</strong> Total Serum Cholesterol
                        </div>
                        <div class="feature-item">
                            <strong>S2:</strong> Low-Density Lipoproteins
                        </div>
                        <div class="feature-item">
                            <strong>S3:</strong> High-Density Lipoproteins
                        </div>
                        <div class="feature-item">
                            <strong>S4:</strong> Total Cholesterol / HDL
                        </div>
                        <div class="feature-item">
                            <strong>S5:</strong> Log of Serum Triglycerides
                        </div>
                        <div class="feature-item">
                            <strong>S6:</strong> Blood Sugar Level
                        </div>
                    </div>
                </div>

                <div class="content-section">
                    <h3>Missing Values Check</h3>
                    <div style="color: #0F5132; background-color: #D1E7DD; padding: 1rem; border-radius: 0.5rem;">
                        ‚úÖ No missing values found in the dataset!
                    </div>
                </div>
            </div>

            <!-- Exploratory Data Analysis Page -->
            <div id="eda-page" class="page">
                <h2>üîç Exploratory Data Analysis</h2>
                
                <div class="content-section">
                    <h3>Target Variable Distribution</h3>
                    <div id="target-distribution-chart" class="chart-container"></div>
                </div>

                <div class="content-section">
                    <h3>Feature Distributions</h3>
                    <div id="feature-distributions-chart" class="chart-container" style="height: 800px;"></div>
                </div>

                <div class="content-section">
                    <h3>Feature Correlation Matrix</h3>
                    <div id="correlation-matrix-chart" class="chart-container"></div>
                </div>

                <div class="content-section">
                    <h3>Feature Distributions by Diabetes Status</h3>
                    <div class="feature-selector">
                        <label for="feature-select">Select feature to analyze:</label>
                        <select id="feature-select">
                            <option value="age">Age</option>
                            <option value="sex">Sex</option>
                            <option value="bmi">BMI</option>
                            <option value="bp">Blood Pressure</option>
                            <option value="s1">Total Serum Cholesterol</option>
                            <option value="s2">Low-Density Lipoproteins</option>
                            <option value="s3">High-Density Lipoproteins</option>
                            <option value="s4">Total Cholesterol / HDL</option>
                            <option value="s5">Log of Serum Triglycerides</option>
                            <option value="s6">Blood Sugar Level</option>
                        </select>
                    </div>
                    <div id="feature-boxplot-chart" class="chart-container"></div>
                </div>
            </div>

            <!-- Model Training & Evaluation Page -->
            <div id="training-page" class="page">
                <h2>ü§ñ Model Training & Evaluation</h2>
                
                <div class="training-controls">
                    <button id="train-models-btn" class="btn btn-primary">
                        ‚ñ∂Ô∏è Train Models
                    </button>
                    <div id="training-status" class="training-status"></div>
                </div>

                <div id="training-results" class="training-results" style="display: none;">
                    <div class="content-section">
                        <h3>Model Performance Comparison</h3>
                        <div class="table-container">
                            <table id="performance-table" class="data-table">
                                <thead>
                                    <tr>
                                        <th>Model</th>
                                        <th>Accuracy</th>
                                        <th>Precision</th>
                                        <th>Recall</th>
                                        <th>F1-Score</th>
                                    </tr>
                                </thead>
                                <tbody id="performance-tbody">
                                    <!-- Performance data will be populated -->
                                </tbody>
                            </table>
                        </div>
                        <div id="performance-chart" class="chart-container"></div>
                    </div>

                    <div class="content-section">
                        <h3>Confusion Matrices</h3>
                        <div class="confusion-matrices">
                            <div id="confusion-lr" class="confusion-matrix"></div>
                            <div id="confusion-rf" class="confusion-matrix"></div>
                            <div id="confusion-svm" class="confusion-matrix"></div>
                        </div>
                    </div>

                    <div class="content-section">
                        <h3>ROC Curves</h3>
                        <div id="roc-curves-chart" class="chart-container"></div>
                    </div>

                    <div class="content-section">
                        <h3>Feature Importance Analysis</h3>
                        <div id="feature-importance-chart" class="chart-container"></div>
                    </div>
                </div>
            </div>

            <!-- Prediction Interface Page -->
            <div id="prediction-page" class="page">
                <h2>üîÆ Diabetes Prediction Interface</h2>
                
                <div id="prediction-warning" class="warning-message">
                    ‚ö†Ô∏è Please train the models first in the 'Model Training & Evaluation' page.
                </div>

                <div id="prediction-form" class="prediction-form" style="display: none;">
                    <h3>Enter Patient Information</h3>
                    
                    <div class="input-grid">
                        <div class="input-group">
                            <label for="age-slider">Age:</label>
                            <input type="range" id="age-slider" min="-3" max="3" step="0.1" value="0">
                            <span id="age-value">0.0</span>
                            <small>Standardized age value</small>
                        </div>
                        
                        <div class="input-group">
                            <label for="sex-select">Sex:</label>
                            <select id="sex-select">
                                <option value="-1">Female</option>
                                <option value="1">Male</option>
                            </select>
                        </div>
                        
                        <div class="input-group">
                            <label for="bmi-slider">BMI:</label>
                            <input type="range" id="bmi-slider" min="-3" max="3" step="0.1" value="0">
                            <span id="bmi-value">0.0</span>
                            <small>Standardized BMI value</small>
                        </div>
                        
                        <div class="input-group">
                            <label for="bp-slider">Blood Pressure:</label>
                            <input type="range" id="bp-slider" min="-3" max="3" step="0.1" value="0">
                            <span id="bp-value">0.0</span>
                            <small>Standardized blood pressure value</small>
                        </div>
                        
                        <div class="input-group">
                            <label for="s1-slider">Total Serum Cholesterol:</label>
                            <input type="range" id="s1-slider" min="-3" max="3" step="0.1" value="0">
                            <span id="s1-value">0.0</span>
                            <small>Standardized cholesterol value</small>
                        </div>
                        
                        <div class="input-group">
                            <label for="s2-slider">Low-Density Lipoproteins:</label>
                            <input type="range" id="s2-slider" min="-3" max="3" step="0.1" value="0">
                            <span id="s2-value">0.0</span>
                            <small>Standardized LDL value</small>
                        </div>
                        
                        <div class="input-group">
                            <label for="s3-slider">High-Density Lipoproteins:</label>
                            <input type="range" id="s3-slider" min="-3" max="3" step="0.1" value="0">
                            <span id="s3-value">0.0</span>
                            <small>Standardized HDL value</small>
                        </div>
                        
                        <div class="input-group">
                            <label for="s4-slider">Total Cholesterol / HDL:</label>
                            <input type="range" id="s4-slider" min="-3" max="3" step="0.1" value="0">
                            <span id="s4-value">0.0</span>
                            <small>Standardized cholesterol ratio</small>
                        </div>
                        
                        <div class="input-group">
                            <label for="s5-slider">Log of Serum Triglycerides:</label>
                            <input type="range" id="s5-slider" min="-3" max="3" step="0.1" value="0">
                            <span id="s5-value">0.0</span>
                            <small>Standardized triglycerides value</small>
                        </div>
                        
                        <div class="input-group">
                            <label for="s6-slider">Blood Sugar Level:</label>
                            <input type="range" id="s6-slider" min="-3" max="3" step="0.1" value="0">
                            <span id="s6-value">0.0</span>
                            <small>Standardized blood sugar value</small>
                        </div>
                    </div>
                    
                    <button id="predict-btn" class="btn btn-primary">
                        üîÆ Predict Diabetes Risk
                    </button>
                    
                    <div id="prediction-results" class="prediction-results" style="display: none;">
                        <h3>Prediction Results</h3>
                        <div class="results-grid">
                            <div id="lr-result" class="result-card"></div>
                            <div id="rf-result" class="result-card"></div>
                            <div id="svm-result" class="result-card"></div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Diabetes Prediction ML Model - JavaScript Implementation
        class DiabetesPredictionApp {
            constructor() {
                this.data = null;
                this.models = null;
                this.scaler = null;
                this.modelsTrained = false;
                this.currentPage = 'overview';
                
                this.init();
            }
            
            init() {
                this.loadSampleData();
                this.setupEventListeners();
                this.setupSliders();
                this.showPage('overview');
                this.populateDataOverview();
            }
            
            // Generate sample diabetes dataset (similar to sklearn diabetes dataset)
            loadSampleData() {
                const n_samples = 442;
                const features = ['age', 'sex', 'bmi', 'bp', 's1', 's2', 's3', 's4', 's5', 's6'];
                
                this.data = {
                    features: features,
                    samples: [],
                    target: []
                };
                
                // Generate random standardized data
                for (let i = 0; i < n_samples; i++) {
                    const sample = {};
                    features.forEach(feature => {
                        if (feature === 'sex') {
                            sample[feature] = Math.random() > 0.5 ? 1 : -1;
                        } else {
                            sample[feature] = (Math.random() - 0.5) * 4; // Standardized values
                        }
                    });
                    
                    // Generate target based on feature combination (simplified)
                    const target_score = sample.bmi * 0.3 + sample.bp * 0.2 + sample.s6 * 0.4 + 
                                       sample.age * 0.1 + Math.random() * 0.5;
                    sample.diabetes = target_score > 0 ? 1 : 0;
                    
                    this.data.samples.push(sample);
                    this.data.target.push(sample.diabetes);
                }
                
                console.log('Sample data loaded:', this.data.samples.length, 'samples');
            }
            
            setupEventListeners() {
                // Navigation
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const page = e.target.getAttribute('data-page');
                        this.showPage(page);
                        this.closeMobileMenu(); // Close mobile menu after navigation
                    });
                });
                
                // Mobile menu functionality
                const mobileMenuBtn = document.getElementById('mobile-menu-btn');
                const mobileOverlay = document.getElementById('mobile-overlay');
                const sidebar = document.querySelector('.sidebar');
                
                mobileMenuBtn.addEventListener('click', () => {
                    this.toggleMobileMenu();
                });
                
                mobileOverlay.addEventListener('click', () => {
                    this.closeMobileMenu();
                });
                
                // Close mobile menu on window resize if screen becomes desktop size
                window.addEventListener('resize', () => {
                    if (window.innerWidth > 768) {
                        this.closeMobileMenu();
                    }
                });
                
                // Train models button
                document.getElementById('train-models-btn').addEventListener('click', () => {
                    this.trainModels();
                });
                
                // Prediction button
                document.getElementById('predict-btn').addEventListener('click', () => {
                    this.makePrediction();
                });
                
                // Feature selector for EDA
                document.getElementById('feature-select').addEventListener('change', (e) => {
                    this.updateFeatureBoxplot(e.target.value);
                });
            }
            
            toggleMobileMenu() {
                const sidebar = document.querySelector('.sidebar');
                const overlay = document.getElementById('mobile-overlay');
                const isOpen = sidebar.classList.contains('open');
                
                if (isOpen) {
                    this.closeMobileMenu();
                } else {
                    this.openMobileMenu();
                }
            }
            
            openMobileMenu() {
                const sidebar = document.querySelector('.sidebar');
                const overlay = document.getElementById('mobile-overlay');
                
                sidebar.classList.add('open');
                overlay.style.display = 'block';
                document.body.style.overflow = 'hidden'; // Prevent background scrolling
            }
            
            closeMobileMenu() {
                const sidebar = document.querySelector('.sidebar');
                const overlay = document.getElementById('mobile-overlay');
                
                sidebar.classList.remove('open');
                overlay.style.display = 'none';
                document.body.style.overflow = ''; // Restore background scrolling
            }
            
            setupSliders() {
                const sliders = ['age', 'bmi', 'bp', 's1', 's2', 's3', 's4', 's5', 's6'];
                
                sliders.forEach(slider => {
                    const sliderElement = document.getElementById(`${slider}-slider`);
                    const valueElement = document.getElementById(`${slider}-value`);
                    
                    sliderElement.addEventListener('input', (e) => {
                        valueElement.textContent = parseFloat(e.target.value).toFixed(1);
                    });
                });
            }
            
            showPage(pageName) {
                // Update navigation
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active');
                });
                document.querySelector(`[data-page="${pageName}"]`).classList.add('active');
                
                // Update page content
                document.querySelectorAll('.page').forEach(page => {
                    page.classList.remove('active');
                });
                document.getElementById(`${pageName}-page`).classList.add('active');
                
                this.currentPage = pageName;
                
                // Load page-specific content
                switch(pageName) {
                    case 'overview':
                        this.populateDataOverview();
                        break;
                    case 'eda':
                        this.createEDACharts();
                        break;
                    case 'training':
                        this.updateTrainingPage();
                        break;
                    case 'prediction':
                        this.updatePredictionPage();
                        break;
                }
            }
            
            populateDataOverview() {
                // Update metrics
                const diabetesCases = this.data.target.filter(x => x === 1).length;
                const noDiabetesCases = this.data.target.filter(x => x === 0).length;
                
                document.getElementById('total-samples').textContent = this.data.samples.length;
                document.getElementById('features-count').textContent = this.data.features.length;
                document.getElementById('diabetes-cases').textContent = diabetesCases;
                document.getElementById('no-diabetes-cases').textContent = noDiabetesCases;
                
                // Populate sample data table
                const tbody = document.getElementById('dataset-tbody');
                tbody.innerHTML = '';
                
                // Show first 10 samples
                for (let i = 0; i < Math.min(10, this.data.samples.length); i++) {
                    const sample = this.data.samples[i];
                    const row = document.createElement('tr');
                    
                    this.data.features.forEach(feature => {
                        const cell = document.createElement('td');
                        cell.textContent = sample[feature].toFixed(3);
                        row.appendChild(cell);
                    });
                    
                    // Add diabetes column
                    const diabetesCell = document.createElement('td');
                    diabetesCell.textContent = sample.diabetes;
                    row.appendChild(diabetesCell);
                    
                    tbody.appendChild(row);
                }
            }
            
            createEDACharts() {
                // Target distribution pie chart
                this.createTargetDistributionChart();
                
                // Feature distributions
                this.createFeatureDistributionsChart();
                
                // Correlation matrix
                this.createCorrelationMatrix();
                
                // Feature boxplot
                this.updateFeatureBoxplot('age');
            }
            
            createTargetDistributionChart() {
                const diabetesCases = this.data.target.filter(x => x === 1).length;
                const noDiabetesCases = this.data.target.filter(x => x === 0).length;
                
                const data = [{
                    labels: ['No Diabetes', 'Diabetes'],
                    values: [noDiabetesCases, diabetesCases],
                    type: 'pie',
                    marker: {
                        colors: ['#28A745', '#DC3545']
                    }
                }];
                
                const layout = {
                    title: 'Distribution of Diabetes Cases',
                    height: window.innerWidth <= 480 ? 250 : 350,
                    responsive: true,
                    autosize: true,
                    margin: { t: 50, l: 10, r: 10, b: 10 }
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: false
                };
                
                Plotly.newPlot('target-distribution-chart', data, layout, config);
            }
            
            createFeatureDistributionsChart() {
                const features = this.data.features;
                
                // Create subplots manually
                const rows = Math.ceil(features.length / 2);
                const cols = 2;
                
                const traces = [];
                
                features.forEach((feature, index) => {
                    const values = this.data.samples.map(sample => sample[feature]);
                    const row = Math.floor(index / cols) + 1;
                    const col = (index % cols) + 1;
                    
                    traces.push({
                        x: values,
                        type: 'histogram',
                        name: feature,
                        xaxis: `x${index + 1}`,
                        yaxis: `y${index + 1}`,
                        showlegend: false
                    });
                });
                
                const layout = {
                    title: 'Feature Distributions',
                    height: window.innerWidth <= 480 ? 600 : 750,
                    grid: {rows: rows, columns: cols, pattern: 'independent'},
                    showlegend: false,
                    responsive: true,
                    autosize: true,
                    margin: { t: 50, l: 40, r: 40, b: 40 }
                };
                
                // Add subplot titles
                for (let i = 0; i < features.length; i++) {
                    layout[`xaxis${i + 1}`] = {title: features[i]};
                    layout[`yaxis${i + 1}`] = {title: 'Count'};
                }
                
                const config = {
                    responsive: true,
                    displayModeBar: false
                };
                
                Plotly.newPlot('feature-distributions-chart', traces, layout, config);
            }
            
            createCorrelationMatrix() {
                const features = this.data.features;
                const correlationMatrix = this.calculateCorrelationMatrix();
                
                const data = [{
                    z: correlationMatrix,
                    x: features,
                    y: features,
                    type: 'heatmap',
                    colorscale: 'RdBu',
                    reversescale: true,
                    showscale: true
                }];
                
                const layout = {
                    title: 'Feature Correlation Matrix',
                    height: window.innerWidth <= 480 ? 250 : 400,
                    xaxis: { title: 'Features', tickangle: 45 },
                    yaxis: { title: 'Features' },
                    responsive: true,
                    autosize: true,
                    margin: { t: 50, l: 60, r: 10, b: 60 }
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: false
                };
                
                Plotly.newPlot('correlation-matrix-chart', data, layout, config);
            }
            
            calculateCorrelationMatrix() {
                const features = this.data.features;
                const matrix = [];
                
                features.forEach((feature1, i) => {
                    const row = [];
                    features.forEach((feature2, j) => {
                        const values1 = this.data.samples.map(sample => sample[feature1]);
                        const values2 = this.data.samples.map(sample => sample[feature2]);
                        const correlation = this.pearsonCorrelation(values1, values2);
                        row.push(correlation);
                    });
                    matrix.push(row);
                });
                
                return matrix;
            }
            
            pearsonCorrelation(x, y) {
                const n = x.length;
                const sum_x = x.reduce((a, b) => a + b, 0);
                const sum_y = y.reduce((a, b) => a + b, 0);
                const sum_xy = x.reduce((acc, xi, i) => acc + xi * y[i], 0);
                const sum_x_sq = x.reduce((acc, xi) => acc + xi * xi, 0);
                const sum_y_sq = y.reduce((acc, yi) => acc + yi * yi, 0);
                
                const numerator = n * sum_xy - sum_x * sum_y;
                const denominator = Math.sqrt((n * sum_x_sq - sum_x * sum_x) * (n * sum_y_sq - sum_y * sum_y));
                
                return denominator === 0 ? 0 : numerator / denominator;
            }
            
            updateFeatureBoxplot(selectedFeature) {
                const diabetesValues = [];
                const noDiabetesValues = [];
                
                this.data.samples.forEach(sample => {
                    if (sample.diabetes === 1) {
                        diabetesValues.push(sample[selectedFeature]);
                    } else {
                        noDiabetesValues.push(sample[selectedFeature]);
                    }
                });
                
                const data = [
                    {
                        y: noDiabetesValues,
                        type: 'box',
                        name: 'No Diabetes',
                        marker: { color: '#28A745' }
                    },
                    {
                        y: diabetesValues,
                        type: 'box',
                        name: 'Diabetes',
                        marker: { color: '#DC3545' }
                    }
                ];
                
                const layout = {
                    title: `${selectedFeature} Distribution by Diabetes Status`,
                    yaxis: { title: selectedFeature },
                    height: window.innerWidth <= 480 ? 250 : 350,
                    responsive: true,
                    autosize: true,
                    margin: { t: 50, l: 50, r: 10, b: 50 }
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: false
                };
                
                Plotly.newPlot('feature-boxplot-chart', data, layout, config);
            }
            
            async trainModels() {
                const trainBtn = document.getElementById('train-models-btn');
                const status = document.getElementById('training-status');
                
                trainBtn.disabled = true;
                trainBtn.innerHTML = '<div class="spinner"></div> Training...';
                status.innerHTML = 'Training models...';
                status.className = 'training-status loading';
                
                // Simulate training delay
                await this.delay(2000);
                
                // Simple model implementations
                this.models = {
                    'Logistic Regression': new LogisticRegressionModel(),
                    'Random Forest': new RandomForestModel(),
                    'SVM': new SVMModel()
                };
                
                // Prepare training data
                const X = this.data.samples.map(sample => 
                    this.data.features.map(feature => sample[feature])
                );
                const y = this.data.target;
                
                // Split data (80/20)
                const splitIndex = Math.floor(X.length * 0.8);
                const X_train = X.slice(0, splitIndex);
                const y_train = y.slice(0, splitIndex);
                const X_test = X.slice(splitIndex);
                const y_test = y.slice(splitIndex);
                
                // Train models
                const results = {};
                for (const [name, model] of Object.entries(this.models)) {
                    await model.fit(X_train, y_train);
                    const predictions = model.predict(X_test);
                    const probabilities = model.predictProba(X_test);
                    
                    results[name] = {
                        accuracy: this.calculateAccuracy(y_test, predictions),
                        precision: this.calculatePrecision(y_test, predictions),
                        recall: this.calculateRecall(y_test, predictions),
                        f1_score: this.calculateF1Score(y_test, predictions),
                        predictions: predictions,
                        probabilities: probabilities,
                        confusion_matrix: this.calculateConfusionMatrix(y_test, predictions)
                    };
                }
                
                this.modelResults = results;
                this.testData = { X_test, y_test };
                this.modelsTrained = true;
                
                trainBtn.disabled = false;
                trainBtn.innerHTML = '‚ñ∂Ô∏è Train Models';
                status.innerHTML = '‚úÖ Models trained successfully!';
                status.className = 'training-status success';
                
                this.displayTrainingResults();
            }
            
            displayTrainingResults() {
                document.getElementById('training-results').style.display = 'block';
                
                // Performance table
                this.updatePerformanceTable();
                
                // Performance chart
                this.createPerformanceChart();
                
                // Confusion matrices
                this.createConfusionMatrices();
                
                // ROC curves
                this.createROCCurves();
                
                // Feature importance
                this.createFeatureImportanceChart();
            }
            
            updatePerformanceTable() {
                const tbody = document.getElementById('performance-tbody');
                tbody.innerHTML = '';
                
                Object.entries(this.modelResults).forEach(([modelName, results]) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${modelName}</td>
                        <td>${results.accuracy.toFixed(3)}</td>
                        <td>${results.precision.toFixed(3)}</td>
                        <td>${results.recall.toFixed(3)}</td>
                        <td>${results.f1_score.toFixed(3)}</td>
                    `;
                    tbody.appendChild(row);
                });
            }
            
            createPerformanceChart() {
                const metrics = ['accuracy', 'precision', 'recall', 'f1_score'];
                const traces = [];
                
                metrics.forEach(metric => {
                    const values = Object.entries(this.modelResults).map(([name, results]) => results[metric]);
                    const models = Object.keys(this.modelResults);
                    
                    traces.push({
                        x: models,
                        y: values,
                        name: metric.replace('_', ' ').toUpperCase(),
                        type: 'bar'
                    });
                });
                
                const layout = {
                    title: 'Model Performance Metrics Comparison',
                    barmode: 'group',
                    height: window.innerWidth <= 480 ? 250 : 350,
                    yaxis: { title: 'Score' },
                    xaxis: { title: 'Model', tickangle: window.innerWidth <= 480 ? 45 : 0 },
                    responsive: true,
                    autosize: true,
                    margin: { t: 50, l: 50, r: 10, b: window.innerWidth <= 480 ? 80 : 50 }
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: false
                };
                
                Plotly.newPlot('performance-chart', traces, layout, config);
            }
            
            createConfusionMatrices() {
                const containers = ['confusion-lr', 'confusion-rf', 'confusion-svm'];
                const modelNames = Object.keys(this.modelResults);
                
                modelNames.forEach((modelName, index) => {
                    const cm = this.modelResults[modelName].confusion_matrix;
                    
                    const data = [{
                        z: cm,
                        x: ['No Diabetes', 'Diabetes'],
                        y: ['No Diabetes', 'Diabetes'],
                        type: 'heatmap',
                        colorscale: 'Blues',
                        showscale: false,
                        text: cm.map(row => row.map(val => val.toString())),
                        texttemplate: '%{text}',
                        textfont: { size: 16 }
                    }];
                    
                    const layout = {
                        title: `Confusion Matrix - ${modelName}`,
                        height: window.innerWidth <= 480 ? 200 : 250,
                        xaxis: { title: 'Predicted' },
                        yaxis: { title: 'Actual' },
                        responsive: true,
                        autosize: true,
                        margin: { t: 50, l: 50, r: 10, b: 50 }
                    };
                    
                    const config = {
                        responsive: true,
                        displayModeBar: false
                    };
                    
                    Plotly.newPlot(containers[index], data, layout, config);
                });
            }
            
            createROCCurves() {
                const traces = [];
                
                Object.entries(this.modelResults).forEach(([name, results]) => {
                    const { fpr, tpr, auc } = this.calculateROC(this.testData.y_test, results.probabilities);
                    
                    traces.push({
                        x: fpr,
                        y: tpr,
                        mode: 'lines',
                        name: `${name} (AUC = ${auc.toFixed(3)})`,
                        type: 'scatter'
                    });
                });
                
                // Add diagonal line
                traces.push({
                    x: [0, 1],
                    y: [0, 1],
                    mode: 'lines',
                    name: 'Random Classifier',
                    line: { dash: 'dash', color: 'gray' }
                });
                
                const layout = {
                    title: 'ROC Curves Comparison',
                    xaxis: { title: 'False Positive Rate', range: [0, 1] },
                    yaxis: { title: 'True Positive Rate', range: [0, 1] },
                    height: window.innerWidth <= 480 ? 250 : 350,
                    responsive: true,
                    autosize: true,
                    margin: { t: 50, l: 50, r: 10, b: 50 }
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: false
                };
                
                Plotly.newPlot('roc-curves-chart', traces, layout, config);
            }
            
            createFeatureImportanceChart() {
                // Use Random Forest feature importance (simplified)
                const rfModel = this.models['Random Forest'];
                const importance = rfModel.getFeatureImportance();
                
                const data = [{
                    x: importance,
                    y: this.data.features,
                    type: 'bar',
                    orientation: 'h',
                    marker: { color: '#FF6B6B' }
                }];
                
                const layout = {
                    title: 'Feature Importance - Random Forest',
                    height: window.innerWidth <= 480 ? 250 : 350,
                    xaxis: { title: 'Importance Score' },
                    yaxis: { title: 'Features' },
                    responsive: true,
                    autosize: true,
                    margin: { t: 50, l: 80, r: 10, b: 50 }
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: false
                };
                
                Plotly.newPlot('feature-importance-chart', data, layout, config);
            }
            
            updateTrainingPage() {
                if (this.modelsTrained) {
                    document.getElementById('training-results').style.display = 'block';
                }
            }
            
            updatePredictionPage() {
                if (this.modelsTrained) {
                    document.getElementById('prediction-warning').style.display = 'none';
                    document.getElementById('prediction-form').style.display = 'block';
                } else {
                    document.getElementById('prediction-warning').style.display = 'block';
                    document.getElementById('prediction-form').style.display = 'none';
                }
            }
            
            makePrediction() {
                if (!this.modelsTrained) return;
                
                // Get input values
                const inputData = [
                    parseFloat(document.getElementById('age-slider').value),
                    parseFloat(document.getElementById('sex-select').value),
                    parseFloat(document.getElementById('bmi-slider').value),
                    parseFloat(document.getElementById('bp-slider').value),
                    parseFloat(document.getElementById('s1-slider').value),
                    parseFloat(document.getElementById('s2-slider').value),
                    parseFloat(document.getElementById('s3-slider').value),
                    parseFloat(document.getElementById('s4-slider').value),
                    parseFloat(document.getElementById('s5-slider').value),
                    parseFloat(document.getElementById('s6-slider').value)
                ];
                
                // Make predictions with all models
                const results = {};
                Object.entries(this.models).forEach(([name, model]) => {
                    const prediction = model.predict([inputData])[0];
                    const probability = model.predictProba([inputData])[0];
                    
                    results[name] = {
                        prediction: prediction,
                        probability: probability
                    };
                });
                
                this.displayPredictionResults(results);
            }
            
            displayPredictionResults(results) {
                const containers = ['lr-result', 'rf-result', 'svm-result'];
                const modelNames = Object.keys(results);
                
                modelNames.forEach((modelName, index) => {
                    const result = results[modelName];
                    const container = document.getElementById(containers[index]);
                    
                    const isHighRisk = result.prediction === 1;
                    const confidence = Math.max(...result.probability) * 100;
                    
                    container.className = `result-card ${isHighRisk ? 'high-risk' : 'low-risk'}`;
                    container.innerHTML = `
                        <h4>${modelName}</h4>
                        <div class="risk-level">${isHighRisk ? 'High Diabetes Risk' : 'Low Diabetes Risk'}</div>
                        <div class="confidence">Confidence: ${confidence.toFixed(1)}%</div>
                    `;
                });
                
                document.getElementById('prediction-results').style.display = 'block';
            }
            
            // Utility functions
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            calculateAccuracy(yTrue, yPred) {
                const correct = yTrue.reduce((acc, actual, i) => acc + (actual === yPred[i] ? 1 : 0), 0);
                return correct / yTrue.length;
            }
            
            calculatePrecision(yTrue, yPred) {
                const tp = yTrue.reduce((acc, actual, i) => acc + (actual === 1 && yPred[i] === 1 ? 1 : 0), 0);
                const fp = yTrue.reduce((acc, actual, i) => acc + (actual === 0 && yPred[i] === 1 ? 1 : 0), 0);
                return tp + fp === 0 ? 0 : tp / (tp + fp);
            }
            
            calculateRecall(yTrue, yPred) {
                const tp = yTrue.reduce((acc, actual, i) => acc + (actual === 1 && yPred[i] === 1 ? 1 : 0), 0);
                const fn = yTrue.reduce((acc, actual, i) => acc + (actual === 1 && yPred[i] === 0 ? 1 : 0), 0);
                return tp + fn === 0 ? 0 : tp / (tp + fn);
            }
            
            calculateF1Score(yTrue, yPred) {
                const precision = this.calculatePrecision(yTrue, yPred);
                const recall = this.calculateRecall(yTrue, yPred);
                return precision + recall === 0 ? 0 : 2 * (precision * recall) / (precision + recall);
            }
            
            calculateConfusionMatrix(yTrue, yPred) {
                const matrix = [[0, 0], [0, 0]];
                yTrue.forEach((actual, i) => {
                    const predicted = yPred[i];
                    matrix[actual][predicted]++;
                });
                return matrix;
            }
            
            calculateROC(yTrue, yProba) {
                // Simplified ROC calculation
                const thresholds = [];
                const fpr = [];
                const tpr = [];
                
                for (let t = 0; t <= 1; t += 0.01) {
                    thresholds.push(t);
                    const yPred = yProba.map(p => p[1] >= t ? 1 : 0);
                    
                    const tp = yTrue.reduce((acc, actual, i) => acc + (actual === 1 && yPred[i] === 1 ? 1 : 0), 0);
                    const fp = yTrue.reduce((acc, actual, i) => acc + (actual === 0 && yPred[i] === 1 ? 1 : 0), 0);
                    const tn = yTrue.reduce((acc, actual, i) => acc + (actual === 0 && yPred[i] === 0 ? 1 : 0), 0);
                    const fn = yTrue.reduce((acc, actual, i) => acc + (actual === 1 && yPred[i] === 0 ? 1 : 0), 0);
                    
                    const tprValue = tp + fn === 0 ? 0 : tp / (tp + fn);
                    const fprValue = fp + tn === 0 ? 0 : fp / (fp + tn);
                    
                    tpr.push(tprValue);
                    fpr.push(fprValue);
                }
                
                // Calculate AUC using trapezoidal rule
                let auc = 0;
                for (let i = 1; i < fpr.length; i++) {
                    auc += (fpr[i] - fpr[i-1]) * (tpr[i] + tpr[i-1]) / 2;
                }
                
                return { fpr, tpr, auc };
            }
        }

        // Simplified ML Model Classes
        class LogisticRegressionModel {
            constructor() {
                this.weights = null;
                this.bias = 0;
            }
            
            async fit(X, y) {
                // Simplified logistic regression using gradient descent
                const learningRate = 0.01;
                const iterations = 1000;
                
                this.weights = new Array(X[0].length).fill(0);
                this.bias = 0;
                
                for (let i = 0; i < iterations; i++) {
                    const predictions = X.map(sample => this.sigmoid(this.linearCombination(sample)));
                    
                    // Update weights
                    for (let j = 0; j < this.weights.length; j++) {
                        let gradient = 0;
                        for (let k = 0; k < X.length; k++) {
                            gradient += (predictions[k] - y[k]) * X[k][j];
                        }
                        this.weights[j] -= learningRate * gradient / X.length;
                    }
                    
                    // Update bias
                    let biasGradient = 0;
                    for (let k = 0; k < X.length; k++) {
                        biasGradient += predictions[k] - y[k];
                    }
                    this.bias -= learningRate * biasGradient / X.length;
                }
            }
            
            predict(X) {
                return X.map(sample => {
                    const prob = this.sigmoid(this.linearCombination(sample));
                    return prob >= 0.5 ? 1 : 0;
                });
            }
            
            predictProba(X) {
                return X.map(sample => {
                    const prob = this.sigmoid(this.linearCombination(sample));
                    return [1 - prob, prob];
                });
            }
            
            linearCombination(sample) {
                return sample.reduce((sum, value, index) => sum + value * this.weights[index], this.bias);
            }
            
            sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }
        }

        class RandomForestModel {
            constructor() {
                this.trees = [];
                this.nTrees = 10;
                this.featureImportance = null;
            }
            
            async fit(X, y) {
                this.trees = [];
                this.featureImportance = new Array(X[0].length).fill(0);
                
                for (let i = 0; i < this.nTrees; i++) {
                    const tree = new DecisionTreeModel();
                    
                    // Bootstrap sample
                    const indices = [];
                    for (let j = 0; j < X.length; j++) {
                        indices.push(Math.floor(Math.random() * X.length));
                    }
                    
                    const X_sample = indices.map(idx => X[idx]);
                    const y_sample = indices.map(idx => y[idx]);
                    
                    await tree.fit(X_sample, y_sample);
                    this.trees.push(tree);
                    
                    // Accumulate feature importance
                    const treeImportance = tree.getFeatureImportance();
                    for (let k = 0; k < treeImportance.length; k++) {
                        this.featureImportance[k] += treeImportance[k];
                    }
                }
                
                // Normalize feature importance
                const total = this.featureImportance.reduce((sum, val) => sum + val, 0);
                this.featureImportance = this.featureImportance.map(val => val / total);
            }
            
            predict(X) {
                return X.map(sample => {
                    const votes = this.trees.map(tree => tree.predict([sample])[0]);
                    const sum = votes.reduce((a, b) => a + b, 0);
                    return sum > this.nTrees / 2 ? 1 : 0;
                });
            }
            
            predictProba(X) {
                return X.map(sample => {
                    const votes = this.trees.map(tree => tree.predict([sample])[0]);
                    const positiveVotes = votes.reduce((a, b) => a + b, 0);
                    const prob = positiveVotes / this.nTrees;
                    return [1 - prob, prob];
                });
            }
            
            getFeatureImportance() {
                return this.featureImportance || new Array(10).fill(0.1);
            }
        }

        class DecisionTreeModel {
            constructor() {
                this.tree = null;
                this.maxDepth = 5;
                this.featureImportance = null;
            }
            
            async fit(X, y) {
                this.featureImportance = new Array(X[0].length).fill(0);
                this.tree = this.buildTree(X, y, 0);
            }
            
            buildTree(X, y, depth) {
                if (depth >= this.maxDepth || y.length <= 1 || new Set(y).size === 1) {
                    const label = y.length === 0 ? 0 : Math.round(y.reduce((a, b) => a + b) / y.length);
                    return { type: 'leaf', label };
                }
                
                const { feature, threshold, leftIndices, rightIndices } = this.findBestSplit(X, y);
                
                if (leftIndices.length === 0 || rightIndices.length === 0) {
                    const label = Math.round(y.reduce((a, b) => a + b) / y.length);
                    return { type: 'leaf', label };
                }
                
                this.featureImportance[feature] += 1;
                
                const leftX = leftIndices.map(i => X[i]);
                const leftY = leftIndices.map(i => y[i]);
                const rightX = rightIndices.map(i => X[i]);
                const rightY = rightIndices.map(i => y[i]);
                
                return {
                    type: 'node',
                    feature,
                    threshold,
                    left: this.buildTree(leftX, leftY, depth + 1),
                    right: this.buildTree(rightX, rightY, depth + 1)
                };
            }
            
            findBestSplit(X, y) {
                let bestGain = -1;
                let bestFeature = 0;
                let bestThreshold = 0;
                let bestLeftIndices = [];
                let bestRightIndices = [];
                
                for (let feature = 0; feature < X[0].length; feature++) {
                    const values = X.map(sample => sample[feature]);
                    const uniqueValues = [...new Set(values)].sort((a, b) => a - b);
                    
                    for (let i = 0; i < uniqueValues.length - 1; i++) {
                        const threshold = (uniqueValues[i] + uniqueValues[i + 1]) / 2;
                        const leftIndices = [];
                        const rightIndices = [];
                        
                        for (let j = 0; j < X.length; j++) {
                            if (X[j][feature] <= threshold) {
                                leftIndices.push(j);
                            } else {
                                rightIndices.push(j);
                            }
                        }
                        
                        if (leftIndices.length === 0 || rightIndices.length === 0) continue;
                        
                        const gain = this.informationGain(y, leftIndices, rightIndices);
                        
                        if (gain > bestGain) {
                            bestGain = gain;
                            bestFeature = feature;
                            bestThreshold = threshold;
                            bestLeftIndices = leftIndices;
                            bestRightIndices = rightIndices;
                        }
                    }
                }
                
                return { feature: bestFeature, threshold: bestThreshold, leftIndices: bestLeftIndices, rightIndices: bestRightIndices };
            }
            
            informationGain(y, leftIndices, rightIndices) {
                const parentEntropy = this.entropy(y);
                const leftY = leftIndices.map(i => y[i]);
                const rightY = rightIndices.map(i => y[i]);
                
                const leftWeight = leftY.length / y.length;
                const rightWeight = rightY.length / y.length;
                
                const weightedEntropy = leftWeight * this.entropy(leftY) + rightWeight * this.entropy(rightY);
                
                return parentEntropy - weightedEntropy;
            }
            
            entropy(y) {
                if (y.length === 0) return 0;
                
                const counts = {};
                y.forEach(label => {
                    counts[label] = (counts[label] || 0) + 1;
                });
                
                let entropy = 0;
                Object.values(counts).forEach(count => {
                    const probability = count / y.length;
                    if (probability > 0) {
                        entropy -= probability * Math.log2(probability);
                    }
                });
                
                return entropy;
            }
            
            predict(X) {
                return X.map(sample => this.predictSample(sample, this.tree));
            }
            
            predictSample(sample, node) {
                if (node.type === 'leaf') {
                    return node.label;
                }
                
                if (sample[node.feature] <= node.threshold) {
                    return this.predictSample(sample, node.left);
                } else {
                    return this.predictSample(sample, node.right);
                }
            }
            
            getFeatureImportance() {
                if (!this.featureImportance) return new Array(10).fill(0.1);
                const total = this.featureImportance.reduce((sum, val) => sum + val, 0);
                return total === 0 ? new Array(10).fill(0.1) : this.featureImportance.map(val => val / total);
            }
        }

        class SVMModel {
            constructor() {
                this.weights = null;
                this.bias = 0;
                this.supportVectors = null;
            }
            
            async fit(X, y) {
                // Simplified SVM using gradient descent (approximation)
                const learningRate = 0.001;
                const iterations = 1000;
                const C = 1.0; // Regularization parameter
                
                this.weights = new Array(X[0].length).fill(0);
                this.bias = 0;
                
                // Convert labels to -1 and 1
                const yTransformed = y.map(label => label === 0 ? -1 : 1);
                
                for (let iter = 0; iter < iterations; iter++) {
                    for (let i = 0; i < X.length; i++) {
                        const sample = X[i];
                        const label = yTransformed[i];
                        const distance = this.linearCombination(sample);
                        
                        if (label * distance < 1) {
                            // Update weights for misclassified sample
                            for (let j = 0; j < this.weights.length; j++) {
                                this.weights[j] += learningRate * (label * sample[j] - 2 * (1/iterations) * this.weights[j]);
                            }
                            this.bias += learningRate * label;
                        } else {
                            // Update weights for correctly classified sample
                            for (let j = 0; j < this.weights.length; j++) {
                                this.weights[j] += learningRate * (-2 * (1/iterations) * this.weights[j]);
                            }
                        }
                    }
                }
            }
            
            predict(X) {
                return X.map(sample => {
                    const distance = this.linearCombination(sample);
                    return distance >= 0 ? 1 : 0;
                });
            }
            
            predictProba(X) {
                return X.map(sample => {
                    const distance = this.linearCombination(sample);
                    // Convert SVM distance to probability using sigmoid
                    const prob = 1 / (1 + Math.exp(-distance));
                    return [1 - prob, prob];
                });
            }
            
            linearCombination(sample) {
                return sample.reduce((sum, value, index) => sum + value * this.weights[index], this.bias);
            }
        }

        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            const app = new DiabetesPredictionApp();
            window.diabetesApp = app; // Make it globally accessible for debugging
        });
    </script>
</body>
</html>